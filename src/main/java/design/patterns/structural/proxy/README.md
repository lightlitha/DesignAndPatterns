# Introduction

The Proxy Pattern comes up with many different variations. Some of the important variations are, Remote Proxy, Virtual Proxy,
and Protection Proxy. In this lesson, we will know more about these variations and we will implement each of them in Java. But
before we do that, let’s get to know more about the Proxy Pattern in general.
The Proxy Pattern is used to create a representative object that controls access to another object, which may be remote, expensive
to create or in need of being secured.
One reason for controlling access to an object is to defer the full cost of its creation and initialization until we actually need to
use it. Another reason could be to act as a local representative for an object that lives in a different JVM. The Proxy can be very
useful in controlling the access to the original object, especially when objects should have different access rights.
In the Proxy Pattern, a client does not directly talk to the original object, it delegates it calls to the proxy object which calls the
methods of the original object. The important point is that the client does not know about the proxy, the proxy acts as an original
object for the client. But there are many variations to this approach

• Proxy: 1a. Maintains a reference that lets the proxy access the real subject. Proxy may refer to a Subject if the RealSubject
and Subject interfaces are the same. 1b. Provides an interface identical to Subject’s so that a proxy can be substituted for the
real subject. 1c. Controls access to the real subject and may be responsible for creating and deleting it.
• Subject: 2a. Defines the common interface for RealSubject and Proxy so that a Proxy can be used anywhere a RealSubject is
expected.
• RealSubject: 3a. Defines the real object that the proxy represents.

There are three main variations to the Proxy Pattern:
• A remote proxy provides a local representative for an object in a different address space.
• A virtual proxy creates expensive objects on demand.
• A protection proxy controls access to the original object. Protection proxies are useful when objects should have different
access rights.

# Remote Proxy

There is a Pizza Company, which has its outlets at various locations. The owner of the company gets a daily report by the staff
members of the company from various outlets. The current application supported by the Pizza Company is a desktop application,
not a web application. So, the owner has to ask his employees to generate the report and send it to him. But now the owner wants
to generate and check the report by his own, so that he can generate it whenever he wants without anyone’s help. The owner
wants you to develop an application for him.
The problem here is that all applications are running at their respective JVMs and the Report Checker application (which we will
design soon) should run in the owner’s local system. The object required to generate the report does not exist in the owner’s
system JVM and you cannot directly call on the remote object.
Remote Proxy is used to solve this problem. We know that the report is generated by the users, so there is an object which is
required to generate the report. All we need is to contact that object which resides in a remote location in order to get the result
that we want. The Remote Proxy acts as a local representative of a remote object. A remote object is an object that lives in the
heap of different JVM. You call methods to the local object which forward that calls on to the remote object.
Your client object acts like its making remote method calls. But it is calling methods on a heap-local proxy object that handles
all the low-level details of network communication.
Java supports the communication between the two objects residing at two different locations (or two different JVMs) using RMI.
RMI is Remote Method Invocation which is used to build the client and service helper objects, right down to creating a client
helper object with the same methods as the remote service. Using RMI you don’t have to write any of the networking or I/O code
yourself. With your client, you call remote methods just like normal method calls on objects running in the client’s local JVM.
RMI also provides the running infrastructure to make it all work, including a lookup service that the client can use to find and
access the remote objects. There is one difference between RMI calls and local method calls. The client helper send the method
call across the network, so there is networking and I/O which involved in the RMI calls.


# Virtual Proxy

The Virtual Proxy pattern is a memory saving technique that recommends postponing an object creation until it is needed; it
is used when creating an object the is expensive in terms of memory usage or processing involved. In a typical application.
different objects make up different parts of the functionality. When an application is started, it may not need all of its objects
to be available immediately. In such cases, the Virtual Proxy pattern suggests deferring objects creation until it is needed by the
application. The object that is created the first time is referenced in the application and the same instance is reused from that
point onwards. The advantage of this approach is a faster application start-up time, as it is not required to created and load all of
the application objects.
Suppose there is a Company object in your application and this object contains a list of employees of the company in a Conta
ctList object. There could be thousands of employees in a company. Loading the Company object from the database along
with the list of all its employees in the ContactList object could be very time consuming. In some cases you don’t even
require the list of the employees, but you are forced to wait until the company and its list of employees loaded into the memory.
One way to save time and memory is to avoid loading of the employee objects until required, and this is done using the Virtual
Proxy. This technique is also known as Lazy Loading where you are fetching the data only when it is required.


# Protection Proxy

In general, objects in an application interact with each other to implement the overall application functionality. Most application
object are generally accessible to all other objects in the application. At times, it may be necessary to restrict the accessibility of
an object only to a limited set of client objects based on their access rights. When a client object tries to access such an object,
the client is given access to the services provided by the object only if the client can furnish proper authentication credentials. In
such cases, a separate object can be designated with the responsibility of verifying the access privileges of different client objects
when they access the actual object. In other words, every client must successfully authenticate with this designated object to get
access to the actual object functionality. Such an object with which a client needs to authenticate to get access to the actual object
can be referred as an object authenticator which is implemented using the Protection Proxy.
Returning back to the ReportGenerator application that we developed for the pizza company, the owner now requires that
only he can generate the daily report. No other employee should be able to do so.
To implement this security feature, we used Protection Proxy which checks if the object which is trying to generate the report is
the owner; in this case, the report gets generated, otherwise it is not.


# When To Use

Proxy is applicable whenever there is a need for a more versatile or sophisticated reference to an object than a simple pointer.
Here are several common situations in which the Proxy pattern is applicable:
• A remote proxy provides a local representative for an object in a different address space.
• A virtual proxy creates expensive objects on demand.
• A protection proxy controls access to the original object. Protection proxies are useful when objects should have different
access rights.


# Other Proxies

• Cache Proxy/Server Proxy: To provide the functionality required to store the results of most frequently used target operations.
The proxy object stores these results in some kind of a repository. When a client object requests the same operation, the proxy
returns the operation results from the storage area without actually accessing the target object.
• Firewall Proxy: The primary use of a firewall proxy is to protect target objects from bad clients. A firewall proxy can also be
used to provide the functionality required to prevent clients from accessing harmful targets.
• Synchronization Proxy: To provide the required functionality to allow safe concurrent accesses to a target object by different
client objects.
• Smart Reference Proxy: To provide the functionality to prevent the accidental disposal/deletion of the target object when
there are clients currently with references to it. To accomplish this, the proxy keeps a count of the number of references to the
target object. The proxy deletes the target object if and when there are no references to it.
• Counting Proxy: To provide some kind of audit mechanism before executing a method on the target object.